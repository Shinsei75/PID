<h1 align="center">Библиотека классического PID регулятора</h1>
### [Основа AlexGyver - PID РЕГУЛЯТОР НА ARDUINO](https://alexgyver.ru/gyverpid/)

## Логика работы
ПИД регулятор принимает на вход две величины:

Входной сигнал *input* – сигнал с датчика: температура, скорость, положение, и т.д;
Установку *setpoint* – величина, к которой регулятор будет стараться регулировать входной сигнал (температуру, скорость, положение…)
С ПИД регулятора выходит выходной (управляющий) сигнал output – безразмерная величина, которая подаётся на управляющее устройство. Это может быть транзистор с ШИМ сигналом, диммер, сервопривод, и т.д. Выходной сигнал должен влиять на входной сигнал: нагреватель нагревает объект с датчиком температуры, мотор крутится и даёт значения для датчика оборотов, и т.д.

Закон управления регулятора устанавливается при помощи коэффициентов Kp, Ki и Kd.

Kp – пропорциональный коэффициент, выходная величина будет увеличиваться пропорционально разнице входного сигнала и установки.
Ki – коэффициент интегрирующей составляющей, отвечает за накапливающуюся ошибку, позволяет сгладить пульсации и нивелировать маленькую ошибку.
Kd – коэффициент дифференциальной составляющей, отвечает за скорость изменения величины, позволяет уменьшить раскачку системы.
  
## Инициализация
Можно инициализировать объект тремя способами:

GyverPID regulator;  // инициализировать без настроек (всё по нулям, dt 100 мс)
GyverPID regulator(kp, ki, kd);// инициализировать с коэффициентами. dt будет стандартно 100 мс
GyverPID regulator(kp, ki, kd, dt);   // инициализировать с коэффициентами и dt (в миллисекундах)

## Режимы и настройки
Направление регулирования: зависит от того, в какую сторону направляется управляемая величина input при увеличении управляющего сигнала output. Например: охлаждение или нагрев, разгон или торможение, и т.д. По умолчанию стоит **NORMAL** – регулятор считает, что увеличение управляющего сигнала output увеличит входной сигнал input. Устанавливается командой

`setDirection(dir);`  // dir – NORMAL или REVERSE

Режим работы: режим регулирования по ошибке входного сигнала **ON_ERROR** или по изменению входного сигнала **ON_RATE**. По умолчанию стоит **ON_ERROR**, его рекомендуется использовать в большинстве случаев, потому что большинство процессов – самоустанавливающиеся (температура нагревателя сама установится в своём максимуме, скорость мотора – тоже). Режим **ON_RATE** рекомендуется использовать в интегрирующих процессах, в которых выходная величина влияет на скорость изменения входной величины, например положение моторизированного слайдера, который не остановится при управляющем сигнале, отличном от нуля. Таким процессом будет проще управлять в режиме **ON_RATE**. Устанавливается командой

`setMode(mode);` // mode – ON_ERROR или ON_RATE

Подробнее про этот режим смотри в самом конце документации, в разделе оптимизации интегральной суммы.

Пределы выхода: ограничение значения выходного сигнала, по умолчанию: 0-255 (для 8 бит ШИМ). Может быть установлено 0-180 для угла сервопривода, и т.д. Устанавливается командой

`setLimits(min, max);`  // установить пределы

Время итерации: время итерации можно изменить в процессе работы (не знаю, зачем, но возможность есть). Время устанавливается в миллисекундах и влияет на функцию getResultTimer(), которая с этим периодом делает новый расчёт управляющего сигнала. Также это время входит в расчёт управляющего сигнала (в И и Д составляющей). Устанавливается командой

`setDt(dt);`  // установка времени итерации в мс

##Установка/чтение параметров

Основные величины регулятора можно менять в любом месте программы любым удобным способом (кнопки, энкодер, передача через UART/GSM/WiFi, как угодно). Коэффициенты регулятора Kp, Ki и Kd можно устанавливать и читать напрямую как члены класса, например

`regulator.Kp = 1.5;`        // установить

`regulator.Ki += 0.7;`       // изменить

`lcd.print(regulator.Kd);`   // читать

Время итерации меняется при помощи метода setDt() (см. выше).

Величины регулятора (вход, установка, выход) также являются членами класса и к ним можно обратиться напрямую для чтения и записи:

`regulator.input = 10;`     // ВХОД регулятора, например текущая температура

`regulator.setpoint = 20;`  // УСТАНОВКА регулятора, например необходимая температура

`analogWrite(regulator.output);`  // ВЫХОД с регулятора можно подавать напрямую на ШИМ или серво

##Тип вычислений

Библиотека имеет режим целочисленных вычислений. Скорость вычислений особо не меняется, но код занимает меньше места и всё-таки должен выполняться быстрее. По умолчанию стоит режим чисел с плавающей точкой, в заголовочном файле библиотеки смотрите ключевое слово *datatype*, datatype будет *float* или *int* в зависимости от настройки: это некоторые переменные и функции. Настройка осуществляется дефайном перед подключением библиотеки:

`#define PID_INTEGER`

`#include "PID.h"`

## Работа с библиотекой
Нужно скормить регулятору текущее значение величины в *input*, нужное значение в *setpoint*, провести расчёт при помощи `getResult()` или `getResultTimer()`, и после этого выходную величину *output* подать на управляющее устройство. Делать это нужно часто для быстрых процессов (стабилизация частоты оборотов шпинделя станка под нагрузкой: dt берём около 10-50 мс), и не очень часто для медленных процессов (удержание заданной температуры бойлера: dt можно взять пару секунд, процесс очень инерционный). Функция `getResult()` делает расчёт в каждый свой вызов и возвращает *output*, а `getResultTimer()` делает расчёт только при срабатывании встроенного таймера. То есть `getResult()` нужно вызывать по своему таймеру (для продвинутых пользователей), а getResultTimer() нужно вызывать как можно чаще, он посчитает только тогда, когда это будет нужно по своему таймеру. После расчёта можно подавать управляющий сигнал (выходную величину *output*) на управляющее устройство.

## Настройка коэффициента

Подбор коэффициентов ПИД регулятора – индивидуальная задача, зависящая от конкретных условий и “железа”.
Первым делом нужно установить dt. Маленький dt для быстрых процессов и побольше для медленных (инертных). Dt влияет на расчёты при неизменных коэффициентах, поэтому dt лучше не менять во время настройки, чтобы не пришлось пересчитывать все остальные коэффициенты. Диапазон коэффициентов: 0.01 – 100, т.е. довольно широк и зависит напрямую от инертности системы и выбранного времени dt. Коэффициенты должны быть положительные, противоположное направление регулирования задаётся в `setDirection()`.
